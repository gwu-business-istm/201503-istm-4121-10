section_id,section_weight,question_id,question_weight,full_credit_criteria:,partial_credit_criteria:
1,0.4,c1,0.16,"uniquely identifies each/every row in a table'; 'an attribute/one or more attributes whose contents/values are unique to the table'; purpose is not required to be answered separately for full credit if definition is clear - e.g.proper definition followed by nothing or '... that is both its definition and purpose'; 'a set of one or more attributes uniquely in a table', 'a column that is unique for a table for all individual rows of that column', 'an item/instance identifier that allows (it) to be uniquely identified'","0.9 for the correct definition and clear discussion of presence and uniqueness constraints but also containing language that confuses 'entities' with 'instances'... even though we didn't get to conceptual design topics yet, expectation is to not use terms improperly/ to stick to the terms introduced thus far; 0.8 for 'an attribute that uniquely identifies a record, and purpose is (something which is unclear)'; 0.8 for 'uniquely identifies (an attribute or some other database term that is not talking about a record), and purpose is to ensure uniqueness'; 0.8 for 'unique identifier for a given table (without using the word 'attribute' or 'column name') and (discussion of presence and uniqueness constraints)'; 0.7 for 'a set of unique values given to a table to identify each data attribute in the specific row' because there is a confusion of terms going on here; 0.6 for 'those with unique value across the rows of a table' and purpose is to 'identify which data to retrieve'; 0.5 for discussion of indices and identification without using the word 'unique' or 'uniqueness'; 0.5 for 'none repeating in the table';"
1,0.4,c2,0.12,"indexes can improve lookup/query performance/efficiency, so businesses can use them to reduce operating costs'; 'speed of querying'; 'makes cost of querying shorter'; 'to finish the work faster'; 'save time'; 'faster searching/processing';",0.5 for 'connect tables together (not quant)'; 0.5 for 'makes it easier to query and connect tables' (not quant); 0.5 for 'reduce the amount of content they have to search through'
1,0.4,c3,0.12,"datatype decisions can affect processing and storage costs, so businesses can decrease costs'; 'speed of querying'; 'efficiency'; 'obviate need to perform additional processing, thus saving time and money'; faster processing/usage and improved data input validity/integrity; 'processing speed' followed by an example of choosing numbers instead of strings for index/id attributes; 'avoid data corruption ... which would cost time, money, effort' to resolve' is a good answer for the benefits of data integrity, and works here as well because datatype constraints help ensure validity; ","0.8 for demonstrating knowledge of what a datatype is and their role while failing to quantify those benefits; 0.8 for correct definition of datatypes followed by shaky discussion of their role/value followed by a conclusion leading to the possibility of higher profits; 0.7 for 'cost and speed as well as ... (other content that makes it unclear of whether you know what a datatype is)'; 0.5 for 'requires no additional formulation/processing' without quantification ; 0.5 for 'minimize risk of (clipping/truncating/missing) data as well as (talk of relationships, which indicate maybe you're confusing datatypes with indices)'; 0.5 for 'use db more effectively for decision-making'"
2,0.3,pd_1_songs,0.045,"{pk: id; fk: none, or artist name with proper assumptions; index: any other field with proper assumptions}; {pk: 'id is the best choice however title and duration_ms also work'; fk: 'there doesnt appear to be one'}; {pk: id; fk: 'artist name could be a foreign key but the table is not given'}","0.9 for {pk: id; ck: title}; 0.8 for {pk:id; fk: artist_name without proper assumptions}; 0.8 for {pk: id, fk: proper identification of a different table's fk}; 0.6 for 'the id attribute is unique for each row'; 0.5 for {pk:id, title; fk: none}; 0.5 for {pk:id; fk:song_id}; 0.5 for {pk:id; fk:id}; 0.5 for {pk: 'could be either id or title b/c unique'; fk: id};"
2,0.3,pd_2_plays,0.06,"{pk: id, fk: each of song_id, listener_id, and maybe also radio_station_id with proper assumptions}","0.9 for {pk: id; fks: song_id, listener_id, ck: radio_station_id}; 0.9 for {pk: id; fks: song_id, listener_id, ck: (song_id, listener_id)}; 0.8 for {pk: id; fks: song_id, listener_id} but saying the fk is a composite fk; 0.8 for {correct pk and fks but including radio_station_id without listing assumptions}; 0.7 for {pk:id; fk: song_id, listener_id, and an attribute from a different table}; 0.7 for {pk:id, started_playing_at; fk: song_id, listener_id}; 0.7 for {pk:id; fk: song_id}; 0.5 for {pk: id, fk: none}; 0.5 for {pk: id, fk: play_id}; 0.2 for {pk: id, started_playing_at; fk: song_id}; 0.1 for 'the id attribute is unique in each row';"
2,0.3,pd_3_thumbs,0.06,"{pk: id, fk: play_id, index: thumb_type with proper assumptions}",0.9 for {pk: 'could be either id or play_id or pressed_at'; fk: play_id}; 0.5 for {pk: id; fk: none}; 0.5 for {pk: id or play_id or thumb_pressed_at; fk: play_id}; 0.5 for 'the id attribute is unique for each row and could be used as a pk';
2,0.3,pd_4_skips,0.045,"{pk: id, fk: play_id}; 0.5 for 'the id attribute is unique for each row and could be used as a pk';","0.9 for {pk: 'could be either id or play_id or skipped_at'; fk: play_id}; 0.7 for 'id is a pk, play_id is a fk, skipped_at is a pk'; 0.5 for {pk:id and attributes from other tables; fk: play_id}; 0.5 for {pk:id, fk:none}; 0.5 for {pk: id, play_id, skipped_at; fk: play_id}; 0.3 for {pk: id, play_id, pressed_at; fk: id, play_id}"
2,0.3,pd_5_listeners,0.045,"{pk: id, fk: none}; {pk: 'id ... could be email_address but id is preferable', fk: none}; {pk: 'id or even full_name'; fk:none}","0.9 for {pk: 'could be id, full_name, or email_address'; fk: 'id because it uniquely identifies each record in the listener_accounts table'}; 0.8 for {pk: id, fk: proper identification of a different table's fk}; 0.8 for {pk: id, fk; fk: 'could be full_name but full_name could also be a regular index'}; 0.7 for {pk:id, fk:full_name} without fullname transformation assumption; 0.7 for 'id is a pk, full_name is a pk, email is a pk'; 0.6 for {pk:id; fk: email_address, full_name}; 0.5 for {pk:id, fk: email_address and attributes from other tables}; 0.5 for {pk:id, fk: email_address}; 0.5 for {pk:email_address, fk:email_address}; 0.5 for {pk:id, fk: cc_holder_name}; 0.5 for {pk: id, full_name, email_address; fk: 'id referencing listener_accounts'}; 0.4 for {pk: id; ck: full_name; fk: attributes in other tables, ccholder_name}"
2,0.3,pd_6_accounts,0.045,"{pk: listener_id, fk: listener_id, index: any other field with proper assumptions}; {pk: cc_number, fk: listener_id}; {pk: 'listener_id, however cc_holder_name and cc_number both work as well'; fk: listener_id} with good assumptions","0.9 for {pk: 'could be listener_name, cc_holder_name, or cc_number'; fk: listener_id}; 0.8 for {pk: cc_number; fk: listener_id, cc_holder_name}; 0.7 for {pk: listener_id; fk: cc_holder_name} without ccholder assumption; 0.7 for {pk: listener_id, ccholdername, ccnumber; fk: listener_id}; 0.7 for {pk: ccholdername; fk: listener_id; 'zip code is primary'}; 0.7 for {pk:listener_id; fk:listener id (referencing the plays table)}; 0.5 for {pk: none; fk: listener_id, cc_holder_name}; 0.5 for {pk: listener_id; fk: cc_number}; 0.5 for {pk: listener_id; fk: none}; 0.5 for {pk: listener_id, cc_number; fk: full_name}; 0.5 for {pk: listener_id; fk: full_name}"
3,0.3,da_1a,0.03,see SQL answers,0.9 for minor syntax errors; else 0.9 for using LIKE instead of equality operator; else 0.7 for using LIKE and wildcard matchers; else 0.7 for forgetting quotes; else 0.5 for using a WHERE clause but improperly
3,0.3,da_1b,0.03,see SQL answers,"0.9 for forgetting the trailing wildcard matcher; else 0.8 for forgetting both wildcard matchers, or for forgetting one and including minor LIKE syntax error; else 0.7 for using LIKE operator; else 0.6 for using a wildcard matcher in WHERE clause; else 0.5 for using a WHERE clause; else 0.2 for selecting listener attributes"
3,0.3,da_2a,0.015,see SQL answers,0.9 for minor syntax errors; else 0.9 for disordered clauses; else 0.9 for sorting in the wrong direction; else 0.9 for using the order and limit strategy without selecting duration_milliseconds; else 0.8 for selecting and ordering by duration_milliseconds but not using LIMIT/TOP 1; else 0.7 for selecting and ordering by duration_milliseconds but not using LIMIT/TOP 1 and not using the right clause name for ORDER BY; else 0.7 for using MAX(duration_milliseconds); else 0.5 for inclusion of MAX(); else 0.4 for using the order and sort approach but forgetting to use LIMIT/TOP; else 0.3 for including duration_milliseconds in SELECT clause; else 0.2 for including duration_milliseconds
3,0.3,da_2b,0.015,see SQL answers,0.9 for minor syntax errors; else 0.9 for disordered clauses; else 0.9 for sorting in the wrong direction; else 0.9 for using the order and limit strategy without selecting duration_milliseconds; else 0.8 for selecting and ordering by duration_milliseconds but not using LIMIT/TOP 1; else 0.7 for using MIN(duration_milliseconds); else 0.5 for inclusion of MIN(); else 0.4 for using the order and sort approach but forgetting to use LIMIT/TOP; 0.3 for using duration_milliseconds in SELECT clause; else 0.2 for including duration_milliseconds
3,0.3,da_3a,0.03,see SQL answers,"0.8 for counting song_id but not uniquely; else 0.7 for proper join, and use of COUNT(); else 0.6 if listing instead of counting songs; else 0.6 for using the proper inner join; else 0.6 for counting song_id but not distinct, and either using a GROUP BY with selection syntax errors or a WHERE clause with errors; else 0.5 for a proper inner join with minor syntax error and using a count; else 0.4 for using count and distinctness; else 0.3 for using COUNT() or distinctness; else 0.2 for a FROM clause"
3,0.3,da_3b,0.045,see SQL answers,0.7 for the proper outer join and where clause; else 0.6 for the proper outer join and where clause but with join syntax error; else 0.6 for proper outer join; else 0.5 for proper join conditions but improper join type; else 0.5 for using an improper inner join and including proper IS NULL in WHERE clause; else 0.4 for using an inner join and NULL syntax error; else 0.4 or 0.3 for using an inner join but optionally improperly; else 0.3 for using COUNT(); else 0.2 for a FROM clause
3,0.3,da_4a,0.03,see SQL answers,"0.9 for not selecting distinct listener attributes; else 0.8 for not selecting distinct and for minor join syntax error; else 0.8 for including extra WHERE clause with errors; else 0.8 if grouping by full_name and counting listener_id but not distinctly; else 0.8 if grouping by full_name and counting distinct listener_id but trying to reference selection aliases in WHERE clause; else 0.6 for proper join clause, possibly with minor syntax errors; else 0.5 for attempted JOIN; else 0.3 for attempted JOIN with fundamental errors; else 0.2 for a FROM clause or a JOIN clause;"
3,0.3,da_4b,0.045,see SQL answers,"0.9 for not selecting distinct; else 0.8 for proper outer join and where clause but with minor syntax errors; else 0.6 for proper outer join; else 0.5 for proper join but improper join type, and use of NULL in WHERE clause; else 0.4 for proper join but improper join type; else 0.3 for selecting listener attributes; else 0.3 for attempted JOIN; else 0.2 for a FROM clause"
3,0.3,da_5a,0.03,see SQL answers,"0.9 for referencing original table name after aliasing to produce an unknown table error; 0.8 for misordering of clauses; else 0.7 for an extra join and filters mixed with join conditions to produce ambiguous selection error; else 0.7 for proper JOIN and WHERE clause conditions; 0.6 for proper JOIN and WHERE clause conditions and either: improper attempt to use GROUP BY, or minor join syntax errors; else 0.6 for proper JOIN and WHERE clause conditions but with minor join or filter syntax errors; else 0.6 for proper join with incorrect filter conditions; else 0.5 for proper WHERE clause conditions; else 0.4 for an improper join and improper filter conditions; else 0.2 for attempting a JOIN or WHERE clause filter"
3,0.3,da_5b,0.03,see SQL answers,0.9 for using numeric operator on a string; 0.9 for use of equality operator instead of IN() operator; 0.8 for misordering of clauses; else 0.8 for minor join syntax errors; else 0.7 for trying to reference selection aliases in the JOIN or WHERE clause; else 0.7 for parentheses syntax errors; else 0.6 for proper JOIN clause with incorrect filter conditions; else 0.5 for proper JOIN clause with incorrect filter conditions and minor join syntax error; else 0.4 for improper join and attempted filter conditions; else 0.2 for attempting a JOIN or a WHERE clause filter
3,0.3,da_5c,0.03,see SQL answers,0.8 for disordered clauses; else 0.8 for forgetting parenthesis in WHERE clause; else 0.7 for trying to reference selection aliases in the JOIN or WHERE clause; else 0.7 for minor join syntax errors and one where clause syntax error; else 0.6 for proper JOIN clause with incorrect filter conditions; else 0.4 for minor join syntax errors and filter syntax errors; else 0.3 for proper join conditions but not proper join type; else 0.3 for improper join and attempted filter conditions; else 0.2 for attempting a JOIN or WHERE clause
3,0.3,da_6a,0.03,see SQL answers,0.9 for syntax error; else 0.7 for proper use of GROUP BY and count distinct but with selection errors; else 0.5 for proper GROUP BY clause and using COUNT(); else 0.4 for proper use of COUNT() or GROUP BY; else 0.3 for using COUNT(); else 0.2 for a proper FROM clause;
3,0.3,da_6b,0.03,see SQL answers,"0.9 for forgetting to order before limiting; 0.8 for proper use of GROUP BY and ORDER BY and LIMIT/TOP, and use of COUNT(); else 0.6 for proper use of GROUP BY and LIMIT/TOP and COUNT(), but forgetting ORDER BY; else 0.5 for proper GROUP BY clause and using COUNT(); else 0.4 for proper GROUP BY clause; else 0.3 for using COUNT(); else 0.2 for a proper FROM clause"
3,0.3,da_6c,0.03,see SQL answers,"0.7 for proper GROUP BY and ORDER BY and LIMIT clauses and using COUNT(); else 0.7 for proper use of GROUP BY and LIMIT/TOP and COUNT(), but forgetting ORDER BY; else 0.6 for proper GROUP BY clause and using COUNT(); else 0.5 for proper WHERE clause; else 0.4 for WHERE clause with minor syntax error; 0.3 for using COUNT(); else 0.2 for a proper FROM clause; "
3,0.3,da_7a,0.03,see SQL answers,0.7 for proper joins and counting songs.id; else 0.6 for proper joins; else 0.5 for an improper extra join; else 0.4 for using COUNT() and attempting a join; else 0.3 for using COUNT(); else 0.3 for attempting joins; else 0.2 for a proper FROM clause; 
3,0.3,da_7b,0.03,see SQL answers,"0.7 for proper outer join and WHERE clause but with a few selection mistakes; 0.6 for proper outer joins; 0.5 for using outer join and/or WHERE clause mentioning NULL; else 0.4 for using outer joins but improperly; else 0.4 for proper join conditions but improper join type, and use of NULL in WHERE clause; else 0.3 for proper join conditions and improper join type and optionally with improper join order or minor join syntax errors; else 0.2 for attempting a JOIN; else 0.2 for using COUNT() and/or distinctness"
3,0.3,da_7c,0.03,see SQL answers,0.7 for using TOP/LIMIT and ORDER BY and GROUP BY clauses; 0.6 for using a TOP/LIMIT clause and ORDER BY clause; else 0.5 for using TOP/LIMIT and ORDER BY and GROUP BY clauses but wrong table join order; else 0.4 for using a TOP or LIMIT clause or proper join; else 0.3 for attempting a join